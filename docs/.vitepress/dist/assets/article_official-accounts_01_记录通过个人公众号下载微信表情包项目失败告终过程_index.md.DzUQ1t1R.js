import{_ as s,o as a,c as i,a5 as t}from"./chunks/framework.DY9GNxgq.js";const e="/assets/01.Dq03pUBm.svg",y=JSON.parse('{"title":"记录通过个人公众号下载微信表情包项目失败告终过程","description":"","frontmatter":{"tags":["公众号","项目"],"categories":["公众号"]},"headers":[],"relativePath":"article/official-accounts/01_记录通过个人公众号下载微信表情包项目失败告终过程/index.md","filePath":"article/official-accounts/01_记录通过个人公众号下载微信表情包项目失败告终过程/index.md","lastUpdated":1730914633000}'),n={name:"article/official-accounts/01_记录通过个人公众号下载微信表情包项目失败告终过程/index.md"},l=t('<h1 id="记录通过个人公众号下载微信表情包项目失败告终过程" tabindex="-1">记录通过个人公众号下载微信表情包项目失败告终过程 <a class="header-anchor" href="#记录通过个人公众号下载微信表情包项目失败告终过程" aria-label="Permalink to &quot;记录通过个人公众号下载微信表情包项目失败告终过程&quot;">​</a></h1><p>起因微信中有很多有趣的表情包，在其他软件上想用时却找不到下载按钮。偶然发现一些公众号可以下载微信收藏的表情包。从而想通过个人公众号将表情包下载到本地。</p><h3 id="项目流程图" tabindex="-1">项目流程图 <a class="header-anchor" href="#项目流程图" aria-label="Permalink to &quot;项目流程图&quot;">​</a></h3><p><img src="'+e+`" alt=""></p><p>根据上图流程建立起了服务端，并且对接了公众号接口校验、通知事件、解析 xml 的功能。但是在公众号发送表情包消息时，服务端接收不了表情包，经过网上文章的探查，微信公众号通知的消息是不支持表情包。服务端会收到<code>[收到不支持的消息类型，暂无法显示]</code>的消息。可是别人的公众号为什么能提供下载表情包的能力呢？又经过一番网上文章的搜查，发现了两种方法。一种是爬虫，一种是利用公众号客服的能力。</p><ol><li>爬虫获取表情包。(个人可做)</li></ol><p>开发者服务器接收公众号通知的消息事件里的内容是没有表情包内容的。可是在小程序后台的私信功能上可以看到用户发的消息，包括表情包。到这里我们就想到了爬虫的方式去获取表情包。但是爬虫是需要处理鉴权、数据获取、获取表情包数据的接口所需要的数据获取，还要考虑怎么做到自动化处理整个流程。开发时间周期长，而且不一定能成功，毕竟不知道会不会出现封禁的风险。</p><ol start="2"><li>公众号客服能力获取表情包。（公众号需要认证）</li></ol><p>根据公众号的文档，是可以将用户发送的消息转发到指定客服上的，还能通过提供的接口能力获取客服的历史消息。按照这个流程轻松就能获取到用户的表情包消息，并且还不用自己存储表情包，成本大大降低。但是这个能力是需要公众号认证的。个人公众号基本无望。</p><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>发现提供下载表情包的公众号，都是公司主体，没发现个人主体。基本就宣告了个人公众号开发开发此功能基本无望。不过可以尝试一下爬虫方式，就是会有点麻烦。我就不折腾了，要保住自己的微信号(现在注册微信号太难了)。虽然没能把这个项目做起来，但是开发过程中还是有一点收获的。</p><h3 id="收获" tabindex="-1">收获 <a class="header-anchor" href="#收获" aria-label="Permalink to &quot;收获&quot;">​</a></h3><ol><li>公众号填写服务器信息时，需要填写服务器的 url、token 等信息，在提交时会发<code>get</code>请求到填写的 url 上，开发者服务器需要做好校验处理，校验成功后需要将<code>query</code>接收的<code>echostr</code>返回给公众号服务器，才能提交成功。不能像<a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Access_Overview.html#%E6%8E%A5%E5%85%A5%E6%A6%82%E8%BF%B0" target="_blank" rel="noreferrer">文档实例代码</a>一样返回<code>true</code>，否则不能提交服务器信息。</li><li>接收公众号通知的消息时，需要注意消息是 xml 数据，不能通过<code>query</code>、<code>body</code>、<code>params</code>的方式获取。需要监听<code>data</code>事件，获取二进制数据并且通过<code>toString</code>方法转换成字符串数据，然后才能解析 xml 数据。</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这是midway 框架的示例代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ctx.req.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> xmlData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;xmlData ----&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parseStringPromise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xmlData));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div>`,14),h=[l];function p(o,r,d,k,c,E){return a(),i("div",{"data-pagefind-body":!0},h)}const _=s(n,[["render",p]]);export{y as __pageData,_ as default};
